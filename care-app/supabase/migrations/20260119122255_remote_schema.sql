drop extension if exists "pg_net";

create type "public"."user_role" as enum ('caregiver', 'care_recipient', 'staff', 'volunteer');

create sequence "public"."event_volunteers_id_seq";


  create table "public"."Account details" (
    "id" bigint generated by default as identity not null,
    "Username" character varying,
    "Password" character varying,
    "Preferences" character varying
      );


alter table "public"."Account details" enable row level security;


  create table "public"."Caregiver Details" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "Name" text,
    "HP" smallint,
    "NRIC" character varying,
    "DOB" date,
    "Religion" text,
    "Address" text,
    "House type" character varying,
    "diet" character varying,
    "Blk info" character varying,
    "user_id" uuid
      );


alter table "public"."Caregiver Details" enable row level security;


  create table "public"."Events" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "Name" character varying,
    "Event Type" character varying,
    "No. of people" smallint,
    "Date and Time" timestamp without time zone,
    "Duration" smallint
      );


alter table "public"."Events" enable row level security;


  create table "public"."Participant Details" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "Name" text,
    "HP" smallint,
    "NRIC" character varying,
    "DOB" date,
    "Religion" text,
    "Address" text,
    "House type" character varying,
    "diet" character varying,
    "Blk info" character varying,
    "user_id" uuid
      );


alter table "public"."Participant Details" enable row level security;


  create table "public"."event_volunteers" (
    "id" bigint not null default nextval('public.event_volunteers_id_seq'::regclass),
    "created_at" timestamp with time zone not null default now(),
    "event_id" bigint not null,
    "volunteer_user_id" uuid not null,
    "status" text not null default 'signed_up'::text
      );


alter table "public"."event_volunteers" enable row level security;


  create table "public"."profiles" (
    "user_id" uuid not null,
    "role" public.user_role,
    "display_name" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."profiles" enable row level security;

alter sequence "public"."event_volunteers_id_seq" owned by "public"."event_volunteers"."id";

CREATE UNIQUE INDEX "Account details_pkey" ON public."Account details" USING btree (id);

CREATE UNIQUE INDEX "Caregiver Details_pkey" ON public."Caregiver Details" USING btree (id);

CREATE UNIQUE INDEX "Caregiver Details_user_id_key" ON public."Caregiver Details" USING btree (user_id);

CREATE UNIQUE INDEX "Events_pkey" ON public."Events" USING btree (id);

CREATE UNIQUE INDEX "Participant Details_pkey" ON public."Participant Details" USING btree (id);

CREATE UNIQUE INDEX "Participant Details_user_id_key" ON public."Participant Details" USING btree (user_id);

CREATE UNIQUE INDEX event_volunteers_event_id_volunteer_user_id_key ON public.event_volunteers USING btree (event_id, volunteer_user_id);

CREATE UNIQUE INDEX event_volunteers_pkey ON public.event_volunteers USING btree (id);

CREATE UNIQUE INDEX event_volunteers_unique_signup ON public.event_volunteers USING btree (event_id, volunteer_user_id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (user_id);

CREATE INDEX profiles_role_idx ON public.profiles USING btree (role);

alter table "public"."Account details" add constraint "Account details_pkey" PRIMARY KEY using index "Account details_pkey";

alter table "public"."Caregiver Details" add constraint "Caregiver Details_pkey" PRIMARY KEY using index "Caregiver Details_pkey";

alter table "public"."Events" add constraint "Events_pkey" PRIMARY KEY using index "Events_pkey";

alter table "public"."Participant Details" add constraint "Participant Details_pkey" PRIMARY KEY using index "Participant Details_pkey";

alter table "public"."event_volunteers" add constraint "event_volunteers_pkey" PRIMARY KEY using index "event_volunteers_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."Caregiver Details" add constraint "Caregiver Details_user_id_key" UNIQUE using index "Caregiver Details_user_id_key";

alter table "public"."Caregiver Details" add constraint "caregiver_user_fk" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."Caregiver Details" validate constraint "caregiver_user_fk";

alter table "public"."Participant Details" add constraint "Participant Details_user_id_key" UNIQUE using index "Participant Details_user_id_key";

alter table "public"."Participant Details" add constraint "participant_user_fk" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."Participant Details" validate constraint "participant_user_fk";

alter table "public"."event_volunteers" add constraint "event_volunteers_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public."Events"(id) ON DELETE CASCADE not valid;

alter table "public"."event_volunteers" validate constraint "event_volunteers_event_id_fkey";

alter table "public"."event_volunteers" add constraint "event_volunteers_event_id_volunteer_user_id_key" UNIQUE using index "event_volunteers_event_id_volunteer_user_id_key";

alter table "public"."event_volunteers" add constraint "event_volunteers_unique_signup" UNIQUE using index "event_volunteers_unique_signup";

alter table "public"."event_volunteers" add constraint "event_volunteers_volunteer_user_id_fkey" FOREIGN KEY (volunteer_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_volunteers" validate constraint "event_volunteers_volunteer_user_id_fkey";

alter table "public"."profiles" add constraint "profiles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_available_months()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
BEGIN
  SELECT json_agg(
    json_build_object(
      'slug', month_slug,
      'label', month_label
    )
    ORDER BY month_slug DESC
  )
  INTO result
  FROM (
    SELECT DISTINCT
      TO_CHAR("Date and Time", 'YYYY-MM') as month_slug,
      TO_CHAR("Date and Time", 'Mon YYYY') as month_label
    FROM "Events"
    WHERE "Date and Time" IS NOT NULL
  ) months;
  
  RETURN COALESCE(result, '[]'::JSON);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_event_types_for_month(month_slug text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  start_date TIMESTAMP WITHOUT TIME ZONE;
  end_date TIMESTAMP WITHOUT TIME ZONE;
  year_val INTEGER;
  month_val INTEGER;
  result JSON;
BEGIN
  -- Parse month_slug (YYYY-MM format)
  year_val := CAST(SPLIT_PART(month_slug, '-', 1) AS INTEGER);
  month_val := CAST(SPLIT_PART(month_slug, '-', 2) AS INTEGER);
  
  -- Calculate UTC date range for the month
  start_date := MAKE_TIMESTAMP(year_val, month_val, 1, 0, 0, 0);
  end_date := MAKE_TIMESTAMP(
    CASE WHEN month_val = 12 THEN year_val + 1 ELSE year_val END,
    CASE WHEN month_val = 12 THEN 1 ELSE month_val + 1 END,
    1, 0, 0, 0
  );
  
  -- Get distinct event types
  SELECT json_agg(DISTINCT "Event Type")
  INTO result
  FROM "Events"
  WHERE "Date and Time" >= start_date
    AND "Date and Time" < end_date
    AND "Event Type" IS NOT NULL;
  
  RETURN COALESCE(result, '[]'::JSON);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_events_for_month(month_slug text, user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  start_date TIMESTAMP WITHOUT TIME ZONE;
  end_date TIMESTAMP WITHOUT TIME ZONE;
  year_val INTEGER;
  month_val INTEGER;
  result JSON;
BEGIN
  -- Parse month_slug (YYYY-MM format)
  year_val := CAST(SPLIT_PART(month_slug, '-', 1) AS INTEGER);
  month_val := CAST(SPLIT_PART(month_slug, '-', 2) AS INTEGER);
  
  -- Calculate UTC date range for the month
  start_date := MAKE_TIMESTAMP(year_val, month_val, 1, 0, 0, 0);
  end_date := MAKE_TIMESTAMP(
    CASE WHEN month_val = 12 THEN year_val + 1 ELSE year_val END,
    CASE WHEN month_val = 12 THEN 1 ELSE month_val + 1 END,
    1, 0, 0, 0
  );
  
  -- Query events with signup counts and user status
  WITH event_data AS (
    SELECT 
      e.id,
      e."Name",
      e."Event Type",
      e."No. of people",
      e."Date and Time",
      e."Duration",
      COALESCE(signup_counts.count, 0) as signup_count,
      COALESCE(user_signups.exists, false) as is_signed_up
    FROM "Events" e
    LEFT JOIN (
      SELECT 
        event_id,
        COUNT(*)::INTEGER as count
      FROM event_volunteers
      WHERE status = 'signed_up'
      GROUP BY event_id
    ) signup_counts ON e.id = signup_counts.event_id
    LEFT JOIN (
      SELECT 
        event_id,
        true as exists
      FROM event_volunteers
      WHERE volunteer_user_id = user_id
        AND status = 'signed_up'
    ) user_signups ON e.id = user_signups.event_id
    WHERE e."Date and Time" >= start_date
      AND e."Date and Time" < end_date
    ORDER BY e."Date and Time" ASC
  )
  SELECT json_agg(
    json_build_object(
      'id', id,
      'Name', "Name",
      'Event Type', "Event Type",
      'No. of people', "No. of people",
      'Date and Time', "Date and Time",
      'Duration', "Duration",
      'signup_count', signup_count,
      'is_signed_up', is_signed_up,
      'is_full', COALESCE(
        "No. of people" > 0 AND signup_count >= "No. of people",
        false
      )
    )
  )
  INTO result
  FROM event_data;
  
  RETURN COALESCE(result, '[]'::JSON);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_latest_event_month()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  latest_date TIMESTAMP WITHOUT TIME ZONE;
  result TEXT;
BEGIN
  SELECT "Date and Time"
  INTO latest_date
  FROM "Events"
  WHERE "Date and Time" IS NOT NULL
  ORDER BY "Date and Time" DESC
  LIMIT 1;
  
  IF latest_date IS NULL THEN
    RETURN NULL;
  END IF;
  
  result := TO_CHAR(latest_date, 'YYYY-MM');
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$begin
  -- Default role: volunteer (change if you want)
  insert into public.profiles (user_id, role, display_name)
  values (new.id, NULL, coalesce(new.raw_user_meta_data->>'display_name', ''))
  on conflict (user_id) do nothing;

  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.volunteer_signup(p_event_id bigint)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_id UUID;
  v_event_exists BOOLEAN;
  v_existing_status TEXT;
  v_already_signed_up BOOLEAN;
  v_signup_count INTEGER;
  v_needed INTEGER;
  v_is_full BOOLEAN;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Not authenticated'
    );
  END IF;
  
  -- Verify event exists
  SELECT EXISTS(SELECT 1 FROM "Events" WHERE id = p_event_id)
  INTO v_event_exists;
  
  IF NOT v_event_exists THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Event does not exist'
    );
  END IF;
  
  -- Check if record exists and get its status
  SELECT status
  INTO v_existing_status
  FROM event_volunteers 
  WHERE event_id = p_event_id 
    AND volunteer_user_id = v_user_id;
  
  -- If already signed up (not cancelled), return error
  IF v_existing_status = 'signed_up' THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Already signed up for this event'
    );
  END IF;
  
  -- Check if event is full (only count active signups)
  SELECT 
    COUNT(*)::INTEGER,
    COALESCE(e."No. of people", 0)
  INTO v_signup_count, v_needed
  FROM "Events" e
  LEFT JOIN event_volunteers ev ON e.id = ev.event_id AND ev.status = 'signed_up'
  WHERE e.id = p_event_id
  GROUP BY e."No. of people";
  
  v_is_full := v_needed > 0 AND v_signup_count >= v_needed;
  
  IF v_is_full THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Event is full'
    );
  END IF;
  
  -- If record exists with cancelled status, update it to signed_up
  IF v_existing_status = 'cancelled' THEN
    UPDATE event_volunteers
    SET status = 'signed_up'
    WHERE event_id = p_event_id
      AND volunteer_user_id = v_user_id;
  ELSE
    -- Otherwise, insert new signup
    INSERT INTO event_volunteers (event_id, volunteer_user_id, status)
    VALUES (p_event_id, v_user_id, 'signed_up');
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'message', 'Successfully signed up for event'
  );
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.volunteer_unsignup(p_event_id bigint)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_id UUID;
  v_signup_exists BOOLEAN;
  v_current_status TEXT;
  v_updated_count INTEGER;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Not authenticated'
    );
  END IF;
  
  -- Check if signup exists and get its status
  SELECT status
  INTO v_current_status
  FROM event_volunteers 
  WHERE event_id = p_event_id 
    AND volunteer_user_id = v_user_id;
  
  IF v_current_status IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'You are not signed up for this event'
    );
  END IF;
  
  -- If already cancelled, return error
  IF v_current_status = 'cancelled' THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Signup is already cancelled'
    );
  END IF;
  
  -- Update status to cancelled instead of deleting
  UPDATE event_volunteers
  SET status = 'cancelled'
  WHERE event_id = p_event_id
    AND volunteer_user_id = v_user_id;
  
  GET DIAGNOSTICS v_updated_count = ROW_COUNT;
  
  IF v_updated_count = 0 THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Failed to cancel signup. The record may be protected by database policies.'
    );
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'message', 'Successfully cancelled signup'
  );
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$function$
;

grant delete on table "public"."Account details" to "anon";

grant insert on table "public"."Account details" to "anon";

grant references on table "public"."Account details" to "anon";

grant select on table "public"."Account details" to "anon";

grant trigger on table "public"."Account details" to "anon";

grant truncate on table "public"."Account details" to "anon";

grant update on table "public"."Account details" to "anon";

grant delete on table "public"."Account details" to "authenticated";

grant insert on table "public"."Account details" to "authenticated";

grant references on table "public"."Account details" to "authenticated";

grant select on table "public"."Account details" to "authenticated";

grant trigger on table "public"."Account details" to "authenticated";

grant truncate on table "public"."Account details" to "authenticated";

grant update on table "public"."Account details" to "authenticated";

grant delete on table "public"."Account details" to "service_role";

grant insert on table "public"."Account details" to "service_role";

grant references on table "public"."Account details" to "service_role";

grant select on table "public"."Account details" to "service_role";

grant trigger on table "public"."Account details" to "service_role";

grant truncate on table "public"."Account details" to "service_role";

grant update on table "public"."Account details" to "service_role";

grant delete on table "public"."Caregiver Details" to "anon";

grant insert on table "public"."Caregiver Details" to "anon";

grant references on table "public"."Caregiver Details" to "anon";

grant select on table "public"."Caregiver Details" to "anon";

grant trigger on table "public"."Caregiver Details" to "anon";

grant truncate on table "public"."Caregiver Details" to "anon";

grant update on table "public"."Caregiver Details" to "anon";

grant delete on table "public"."Caregiver Details" to "authenticated";

grant insert on table "public"."Caregiver Details" to "authenticated";

grant references on table "public"."Caregiver Details" to "authenticated";

grant select on table "public"."Caregiver Details" to "authenticated";

grant trigger on table "public"."Caregiver Details" to "authenticated";

grant truncate on table "public"."Caregiver Details" to "authenticated";

grant update on table "public"."Caregiver Details" to "authenticated";

grant delete on table "public"."Caregiver Details" to "service_role";

grant insert on table "public"."Caregiver Details" to "service_role";

grant references on table "public"."Caregiver Details" to "service_role";

grant select on table "public"."Caregiver Details" to "service_role";

grant trigger on table "public"."Caregiver Details" to "service_role";

grant truncate on table "public"."Caregiver Details" to "service_role";

grant update on table "public"."Caregiver Details" to "service_role";

grant delete on table "public"."Events" to "anon";

grant insert on table "public"."Events" to "anon";

grant references on table "public"."Events" to "anon";

grant select on table "public"."Events" to "anon";

grant trigger on table "public"."Events" to "anon";

grant truncate on table "public"."Events" to "anon";

grant update on table "public"."Events" to "anon";

grant delete on table "public"."Events" to "authenticated";

grant insert on table "public"."Events" to "authenticated";

grant references on table "public"."Events" to "authenticated";

grant select on table "public"."Events" to "authenticated";

grant trigger on table "public"."Events" to "authenticated";

grant truncate on table "public"."Events" to "authenticated";

grant update on table "public"."Events" to "authenticated";

grant delete on table "public"."Events" to "service_role";

grant insert on table "public"."Events" to "service_role";

grant references on table "public"."Events" to "service_role";

grant select on table "public"."Events" to "service_role";

grant trigger on table "public"."Events" to "service_role";

grant truncate on table "public"."Events" to "service_role";

grant update on table "public"."Events" to "service_role";

grant delete on table "public"."Participant Details" to "anon";

grant insert on table "public"."Participant Details" to "anon";

grant references on table "public"."Participant Details" to "anon";

grant select on table "public"."Participant Details" to "anon";

grant trigger on table "public"."Participant Details" to "anon";

grant truncate on table "public"."Participant Details" to "anon";

grant update on table "public"."Participant Details" to "anon";

grant delete on table "public"."Participant Details" to "authenticated";

grant insert on table "public"."Participant Details" to "authenticated";

grant references on table "public"."Participant Details" to "authenticated";

grant select on table "public"."Participant Details" to "authenticated";

grant trigger on table "public"."Participant Details" to "authenticated";

grant truncate on table "public"."Participant Details" to "authenticated";

grant update on table "public"."Participant Details" to "authenticated";

grant delete on table "public"."Participant Details" to "service_role";

grant insert on table "public"."Participant Details" to "service_role";

grant references on table "public"."Participant Details" to "service_role";

grant select on table "public"."Participant Details" to "service_role";

grant trigger on table "public"."Participant Details" to "service_role";

grant truncate on table "public"."Participant Details" to "service_role";

grant update on table "public"."Participant Details" to "service_role";

grant delete on table "public"."event_volunteers" to "anon";

grant insert on table "public"."event_volunteers" to "anon";

grant references on table "public"."event_volunteers" to "anon";

grant select on table "public"."event_volunteers" to "anon";

grant trigger on table "public"."event_volunteers" to "anon";

grant truncate on table "public"."event_volunteers" to "anon";

grant update on table "public"."event_volunteers" to "anon";

grant delete on table "public"."event_volunteers" to "authenticated";

grant insert on table "public"."event_volunteers" to "authenticated";

grant references on table "public"."event_volunteers" to "authenticated";

grant select on table "public"."event_volunteers" to "authenticated";

grant trigger on table "public"."event_volunteers" to "authenticated";

grant truncate on table "public"."event_volunteers" to "authenticated";

grant update on table "public"."event_volunteers" to "authenticated";

grant delete on table "public"."event_volunteers" to "service_role";

grant insert on table "public"."event_volunteers" to "service_role";

grant references on table "public"."event_volunteers" to "service_role";

grant select on table "public"."event_volunteers" to "service_role";

grant trigger on table "public"."event_volunteers" to "service_role";

grant truncate on table "public"."event_volunteers" to "service_role";

grant update on table "public"."event_volunteers" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";


  create policy "caregiver_select_own"
  on "public"."Caregiver Details"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "caregiver_update_own"
  on "public"."Caregiver Details"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "events_select_authenticated"
  on "public"."Events"
  as permissive
  for select
  to authenticated
using (true);



  create policy "participant_select_own"
  on "public"."Participant Details"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "participant_update_own"
  on "public"."Participant Details"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "staff can view all signups"
  on "public"."event_volunteers"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.user_id = auth.uid()) AND (p.role = 'staff'::public.user_role)))));



  create policy "volunteers can insert their signup"
  on "public"."event_volunteers"
  as permissive
  for insert
  to authenticated
with check ((volunteer_user_id = auth.uid()));



  create policy "volunteers can view their signups"
  on "public"."event_volunteers"
  as permissive
  for select
  to authenticated
using ((volunteer_user_id = auth.uid()));



  create policy "profiles_select_own"
  on "public"."profiles"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "profiles_update_own"
  on "public"."profiles"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


